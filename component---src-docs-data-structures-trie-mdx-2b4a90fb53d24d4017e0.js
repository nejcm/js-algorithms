(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{C7UQ:function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return s})),a.d(t,"default",(function(){return d}));a("5hJT"),a("W1QL"),a("K/PF"),a("t91x"),a("75LO"),a("PJhk"),a("mXGw");var r=a("/FXl"),n=a("TjRS");a("aD51");function i(){return(i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var r in a)Object.prototype.hasOwnProperty.call(a,r)&&(e[r]=a[r])}return e}).apply(this,arguments)}var s={};void 0!==s&&s&&s===Object(s)&&Object.isExtensible(s)&&!s.hasOwnProperty("__filemeta")&&Object.defineProperty(s,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/docs/DataStructures/Trie.mdx"}});var o={_frontmatter:s},c=n.a;function d(e){var t=e.components,a=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,["components"]);return Object(r.b)(c,i({},o,a,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"trie"},"Trie"),Object(r.b)("p",null,"Also called digital tree or prefix tree, is a kind of search treeâ€”an ordered\ntree data structure used to store a dynamic set or associative array where the\nkeys are usually strings. Unlike a binary search tree, no node in the tree\nstores the key associated with that node; instead, its position in the tree\ndefines the key with which it is associated; i.e., the value of the key is\ndistributed across the structure. All the descendants of a node have a common\nprefix of the string associated with that node, and the root is associated with\nthe empty string. Keys tend to be associated with leaves, though some inner\nnodes may correspond to keys of interest. Hence, keys are not necessarily\nassociated with every node. For the space-optimized presentation of prefix tree,\nsee compact prefix tree."),Object(r.b)("p",null,"In the example shown, keys are listed in the nodes and values below them. Each\ncomplete English word has an arbitrary integer value associated with it. A trie\ncan be seen as a tree-shaped deterministic finite automaton. Each finite\nlanguage is generated by a trie automaton, and each trie can be compressed into\na deterministic acyclic finite state automaton."),Object(r.b)("p",null,"Though tries can be keyed by character strings, they need not be. The same\nalgorithms can be adapted to serve similar functions on ordered lists of any\nconstruct; e.g., permutations on a list of digits or shapes. In particular, a\nbitwise trie is keyed on the individual bits making up any fixed-length binary\ndatum, such as an integer or memory address. (Source: Wikipedia)"),Object(r.b)("p",null,Object(r.b)("img",{alt:"Data Structure Visualization",src:"https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/1024px-Trie_example.svg.png"})),Object(r.b)("h2",{id:"references"},"References"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",i({parentName:"li"},{href:"https://www.geeksforgeeks.org/trie-insert-and-search/"}),"Geeksforgeeks")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",i({parentName:"li"},{href:"https://en.wikipedia.org/wiki/Trie"}),"Wikipedia")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",i({parentName:"li"},{href:"https://www.youtube.com/watch?v=zIjfhVPRZCg"}),"YouTube")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",i({parentName:"li"},{href:"https://www.hackerearth.com/practice/data-structures/advanced-data-structures/trie-keyword-tree/tutorial/"}),"Hackerearth"))))}void 0!==d&&d&&d===Object(d)&&Object.isExtensible(d)&&!d.hasOwnProperty("__filemeta")&&Object.defineProperty(d,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/docs/DataStructures/Trie.mdx"}}),d.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-docs-data-structures-trie-mdx-2b4a90fb53d24d4017e0.js.map