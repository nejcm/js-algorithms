{"version":3,"sources":["webpack:///../src/docs/Algorithms/Pattern/ZAlgorithm.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"wPAMaA,G,UAAe,S,4NAC5B,IAAMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,YAACJ,EAAD,eAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,eADR,eAGA,sEAAqD,0BAAYC,WAAW,KAAvB,KAArD,gCAAmI,0BAAYA,WAAW,KAAvB,KAAnI,oBACU,0BAAYA,WAAW,KAAvB,gBADV,KAEA,uCAAsB,0BAAYA,WAAW,KAAvB,KAAtB,cAAkF,0BAAYA,WAAW,KAAvB,KAAlF,sCAAsK,0BAAYA,WAAW,KAAvB,KAAtK,UAA8N,0BAAYA,WAAW,KAAvB,QAA9N,oDAC6C,0BAAYA,WAAW,KAAvB,QAD7C,8BAC4H,0BAAYA,WAAW,KAAvB,KAD5H,cAEM,0BAAYA,WAAW,KAAvB,KAFN,uDAE2G,0BAAYA,WAAW,KAAvB,KAF3G,iCAGE,0BAAYA,WAAW,KAAvB,KAHF,0BAG0E,0BAAYA,WAAW,KAAvB,KAH1E,8DAIF,0BAAYA,WAAW,KAAvB,KAJE,cAI0D,0BAAYA,WAAW,KAAvB,QAJ1D,gFAMA,kCAAiB,0BAAYA,WAAW,KAAvB,KAAjB,mDAAkH,0BAAYA,WAAW,KAAvB,gBAAlH,qJAE4C,0BAAYA,WAAW,KAAvB,KAF5C,SAEmG,0BAAYA,WAAW,KAAvB,KAFnG,OAEwJ,0BAAYA,WAAW,KAAvB,SAFxJ,+BAGO,0BAAYA,WAAW,KAAvB,UAHP,uCAGiG,0BAAYA,WAAW,KAAvB,KAHjG,cAG6J,0BAAYA,WAAW,KAAvB,iBAH7J,SAIF,0BAAYA,WAAW,KAAvB,YAJE,gFAKF,0BAAYA,WAAW,KAAvB,eALE,UAKgE,0BAAYA,WAAW,KAAvB,SALhE,2BAK6I,0BAAYA,WAAW,KAAvB,KAL7I,QAKmM,0BAAYA,WAAW,KAAvB,KALnM,iBAKkQ,0BAAYA,WAAW,KAAvB,WALlQ,QAMF,0BAAYA,WAAW,KAAvB,WANE,yBAOA,iBAAQ,CACN,GAAM,cADR,cAGA,yBACE,qBAAOA,WAAW,SAChB,kBAAIA,WAAW,SACb,8BAAIA,WAAW,MAAS,CACtB,MAAS,OADX,QAGA,8BAAIA,WAAW,MAAS,CACtB,MAAS,WADX,iBAGA,8BAAIA,WAAW,MAAS,CACtB,MAAS,WADX,WAGA,8BAAIA,WAAW,MAAS,CACtB,MAAS,WADX,SAGA,8BAAIA,WAAW,MAAS,CACtB,MAAS,WADX,SAGA,8BAAIA,WAAW,MAAS,CACtB,MAAS,SADX,cAKJ,qBAAOA,WAAW,SAChB,kBAAIA,WAAW,SACb,8BAAIA,WAAW,MAAS,CACtB,MAAS,OADX,eAGA,8BAAIA,WAAW,MAAS,CACtB,MAAS,WADX,KAGA,8BAAIA,WAAW,MAAS,CACtB,MAAS,WADX,SAGA,8BAAIA,WAAW,MAAS,CACtB,MAAS,WADX,eAGA,8BAAIA,WAAW,MAAS,CACtB,MAAS,WADX,KAGA,8BAAIA,WAAW,MAAS,CACtB,MAAS,aAKjB,wHAEA,iBAAQ,CACN,GAAM,cADR,cAGA,sBACE,kBAAIA,WAAW,MAAK,6BAAGA,WAAW,MAAS,CACvC,KAAQ,uFADQ,kBAGpB,kBAAIA,WAAW,MAAK,6BAAGA,WAAW,MAAS,CACvC,KAAQ,2FADQ,gBAGpB,kBAAIA,WAAW,MAAK,6BAAGA,WAAW,MAAS,CACvC,KAAQ,mDADQ,yC,0NAQ1BJ,EAAWK,gBAAiB","file":"component---src-docs-algorithms-pattern-z-algorithm-mdx-a7a100464529b53a8a2b.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/js-algorithms/js-algorithms/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"z-algorithm\"\n    }}>{`Z algorithm`}</h1>\n    <p>{`The Z-algorithm finds occurrences of a \"word\" `}<inlineCode parentName=\"p\">{`W`}</inlineCode>{` within a main \"text string\" `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{` in\nlinear time `}<inlineCode parentName=\"p\">{`O(|W| + |T|)`}</inlineCode>{`.`}</p>\n    <p>{`Given a string `}<inlineCode parentName=\"p\">{`S`}</inlineCode>{` of length `}<inlineCode parentName=\"p\">{`n`}</inlineCode>{`, the algorithm produces an array, `}<inlineCode parentName=\"p\">{`Z`}</inlineCode>{` where `}<inlineCode parentName=\"p\">{`Z[i]`}</inlineCode>{`\nrepresents the longest substring starting from `}<inlineCode parentName=\"p\">{`S[i]`}</inlineCode>{` which is also a prefix of `}<inlineCode parentName=\"p\">{`S`}</inlineCode>{`.\nFinding `}<inlineCode parentName=\"p\">{`Z`}</inlineCode>{` for the string obtained by concatenating the word, `}<inlineCode parentName=\"p\">{`W`}</inlineCode>{` with a nonce character,\nsay `}<inlineCode parentName=\"p\">{`$`}</inlineCode>{` followed by the text, `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{`, helps with pattern matching, for if there is some index\n`}<inlineCode parentName=\"p\">{`i`}</inlineCode>{` such that `}<inlineCode parentName=\"p\">{`Z[i]`}</inlineCode>{` equals the pattern length, then the pattern must be present at that\npoint.`}</p>\n    <p>{`While the `}<inlineCode parentName=\"p\">{`Z`}</inlineCode>{` array can be computed with two nested loops in `}<inlineCode parentName=\"p\">{`O(|W| * |T|)`}</inlineCode>{` time, the\nfollowing strategy shows how to obtain it in linear time, based on the idea that as we\niterate over the letters in the string (index `}<inlineCode parentName=\"p\">{`i`}</inlineCode>{` from `}<inlineCode parentName=\"p\">{`1`}</inlineCode>{` to `}<inlineCode parentName=\"p\">{`n - 1`}</inlineCode>{`), we maintain an\ninterval `}<inlineCode parentName=\"p\">{`[L, R]`}</inlineCode>{` which is the interval with maximum `}<inlineCode parentName=\"p\">{`R`}</inlineCode>{` such that `}<inlineCode parentName=\"p\">{`1 ≤ L ≤ i ≤ R`}</inlineCode>{` and\n`}<inlineCode parentName=\"p\">{`S[L...R]`}</inlineCode>{` is a prefix that is also a substring (if no such interval exists, just let\n`}<inlineCode parentName=\"p\">{`L = R = - 1`}</inlineCode>{`). For `}<inlineCode parentName=\"p\">{`i = 1`}</inlineCode>{`, we can simply compute `}<inlineCode parentName=\"p\">{`L`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`R`}</inlineCode>{` by comparing `}<inlineCode parentName=\"p\">{`S[0...]`}</inlineCode>{` to\n`}<inlineCode parentName=\"p\">{`S[1...]`}</inlineCode>{`. (Source: Wikipedia)`}</p>\n    <h2 {...{\n      \"id\": \"complexity\"\n    }}>{`Complexity`}</h2>\n    <table>\n      <thead parentName=\"table\">\n        <tr parentName=\"thead\">\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Name`}</th>\n          <th parentName=\"tr\" {...{\n            \"align\": \"center\"\n          }}>{`Preprocessing`}</th>\n          <th parentName=\"tr\" {...{\n            \"align\": \"center\"\n          }}>{`Average`}</th>\n          <th parentName=\"tr\" {...{\n            \"align\": \"center\"\n          }}>{`Worst`}</th>\n          <th parentName=\"tr\" {...{\n            \"align\": \"center\"\n          }}>{`Space`}</th>\n          <th parentName=\"tr\" {...{\n            \"align\": \"left\"\n          }}>{`Comments`}</th>\n        </tr>\n      </thead>\n      <tbody parentName=\"table\">\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Z algorithm`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": \"center\"\n          }}>{`m`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": \"center\"\n          }}>{`n + m`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": \"center\"\n          }}>{`n `}{`*`}{` m`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": \"center\"\n          }}>{`m`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": \"left\"\n          }}></td>\n        </tr>\n      </tbody>\n    </table>\n    <p>{`*`}{` Where n = length of the source; m = length of the query pattern; k = size of the\nAlphabet`}</p>\n    <h2 {...{\n      \"id\": \"references\"\n    }}>{`References`}</h2>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/\"\n        }}>{`Geeksforgeeks`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://www.hackerearth.com/practice/algorithms/string-algorithm/z-algorithm/tutorial/\"\n        }}>{`Hackerearth`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://ivanyu.me/blog/2013/10/15/z-algorithm/\"\n        }}>{`Z Algorithm by Ivan Yurchenko`}</a></li>\n    </ul>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}