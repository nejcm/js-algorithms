(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{MgFt:function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return o})),a.d(t,"default",(function(){return c}));a("5hJT"),a("W1QL"),a("K/PF"),a("t91x"),a("75LO"),a("PJhk"),a("mXGw");var r=a("/FXl"),n=a("TjRS");a("aD51");function l(){return(l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var r in a)Object.prototype.hasOwnProperty.call(a,r)&&(e[r]=a[r])}return e}).apply(this,arguments)}var o={};void 0!==o&&o&&o===Object(o)&&Object.isExtensible(o)&&!o.hasOwnProperty("__filemeta")&&Object.defineProperty(o,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/docs/Algorithms/Graph/BellmanFord.mdx"}});var i={_frontmatter:o},s=n.a;function c(e){var t=e.components,a=function(e,t){if(null==e)return{};var a,r,n={},l=Object.keys(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,["components"]);return Object(r.b)(s,l({},i,a,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"bellman-ford"},"Bellman ford"),Object(r.b)("p",null,"It is an algorithm that computes shortest paths from a single source vertex to\nall of the other vertices in a weighted digraph. It is slower than Dijkstra's\nalgorithm for the same problem, but more versatile, as it is capable of handling\ngraphs in which some of the edge weights are negative numbers."),Object(r.b)("p",null,'Negative edge weights are found in various applications of graphs, hence the\nusefulness of this algorithm. If a graph contains a "negative cycle" (i.e. a\ncycle whose edges sum to a negative value) that is reachable from the source,\nthen there is no cheapest path: any path that has a point on the negative cycle\ncan be made cheaper by one more walk around the negative cycle. In such a case,\nthe Bellman–Ford algorithm can detect and report the negative cycle.'),Object(r.b)("p",null,"Like Dijkstra's algorithm, Bellman–Ford proceeds by relaxation, in which\napproximations to the correct distance are replaced by better ones until they\neventually reach the solution. In both algorithms, the approximate distance to\neach vertex is always an overestimate of the true distance, and is replaced by\nthe minimum of its old value and the length of a newly found path. However,\nDijkstra's algorithm uses a priority queue to greedily select the closest vertex\nthat has not yet been processed, and performs this relaxation process on all of\nits outgoing edges; by contrast, the Bellman–Ford algorithm simply relaxes all\nthe edges. In each of these repetitions, the number of vertices with correctly\ncalculated distances grows, from which it follows that eventually all vertices\nwill have their correct distances. This method allows the Bellman–Ford algorithm\nto be applied to a wider class of inputs than Dijkstra. ","[Source: Wikipedia]"),Object(r.b)("p",null,Object(r.b)("img",{alt:"Bellman-Ford",src:"https://upload.wikimedia.org/wikipedia/commons/2/2e/Shortest_path_Dijkstra_vs_BellmanFord.gif"})),Object(r.b)("h2",{id:"complexity"},"Complexity"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",l({parentName:"tr"},{align:"left"}),"Name"),Object(r.b)("th",l({parentName:"tr"},{align:"center"}),"Worst time"),Object(r.b)("th",l({parentName:"tr"},{align:"center"}),"Best time"),Object(r.b)("th",l({parentName:"tr"},{align:"left"}),"Comments"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",l({parentName:"tr"},{align:"left"}),"Bellman ford"),Object(r.b)("td",l({parentName:"tr"},{align:"center"}),"v ","*"," e"),Object(r.b)("td",l({parentName:"tr"},{align:"center"}),"e"),Object(r.b)("td",l({parentName:"tr"},{align:"left"}))))),Object(r.b)("p",null,"*"," Where v = number of vertices; e = number of edges"),Object(r.b)("h2",{id:"references"},"References"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",l({parentName:"li"},{href:"https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/"}),"Geeksforgeeks")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",l({parentName:"li"},{href:"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm"}),"Wikipedia")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",l({parentName:"li"},{href:"https://www.youtube.com/watch?v=FtN3BYH2Zes&ab_channel=AbdulBari"}),"YouTube")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",l({parentName:"li"},{href:"https://www.programiz.com/dsa/bellman-ford-algorithm"}),"Programiz")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",l({parentName:"li"},{href:"https://cp-algorithms.com/graph/bellman_ford.html"}),"cp-algorithms")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",l({parentName:"li"},{href:"https://www.tutorialspoint.com/Bellman-Ford-Algorithm-for-Shortest-Paths"}),"Tutorialspoint"))))}void 0!==c&&c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/docs/Algorithms/Graph/BellmanFord.mdx"}}),c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-docs-algorithms-graph-bellman-ford-mdx-c212e913718639f3b37b.js.map