"use strict";(self.webpackChunk_nejcm_js_algorithms=self.webpackChunk_nejcm_js_algorithms||[]).push([[4724],{2084:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"Algorithms/Sorting/TimSort","title":"Tim Sort","description":"View the implementation","source":"@site/docs/Algorithms/Sorting/TimSort.mdx","sourceDirName":"Algorithms/Sorting","slug":"/Algorithms/Sorting/TimSort","permalink":"/js-algorithms/docs/Algorithms/Sorting/TimSort","draft":false,"unlisted":false,"editUrl":"https://github.com/nejcm/js-algorithms/edit/main/docs/Algorithms/Sorting/TimSort.mdx","tags":[],"version":"current","frontMatter":{"name":"Tim sort","route":"/algorithms/sorting/tim-sort","menu":"Sorting"},"sidebar":"tutorialSidebar","previous":{"title":"Shell Sort","permalink":"/js-algorithms/docs/Algorithms/Sorting/ShellSort"},"next":{"title":"Levenshtein distance","permalink":"/js-algorithms/docs/Algorithms/String/LevenshteinDistance"}}');var r=n(4848),s=n(8453);const o={name:"Tim sort",route:"/algorithms/sorting/tim-sort",menu:"Sorting"},l="Tim Sort",h={},a=[{value:"Complexity",id:"complexity",level:2},{value:"Implementations",id:"implementations",level:2},{value:"References",id:"references",level:2}];function c(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"tim-sort",children:"Tim Sort"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://github.com/nejcm/js-algorithms/blob/master/src/algorithms/sorting/tim-sort/index.ts",children:"View the implementation"})}),"\n",(0,r.jsx)(t.p,{children:"Timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort,\ndesigned to perform well on many kinds of real-world data. It was implemented by Tim\nPeters in 2002 for use in the Python programming language. The algorithm finds\nsubsequences of the data that are already ordered (runs) and uses them to sort the\nremainder more efficiently. This is done by merging runs until certain criteria are\nfulfilled. (Source: Wikipedia)"}),"\n",(0,r.jsx)(t.p,{children:"We divide the Array into blocks known as Run. We sort those runs using insertion sort one\nby one and then merge those runs using combine function used in merge sort. If the size of\nArray is less than run, then Array get sorted just by using Insertion Sort. The size of\nrun may vary from 32 to 64 depending upon the size of the array. Note that merge function\nperforms well when sizes subarrays are powers of 2. The idea is based on the fact that\ninsertion sort performs well for small arrays. (Source: Geeksforgeeks)"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"https://upload.wikimedia.org/wikipedia/commons/thumb/e/e4/Copy_galloping_mode_timsort%282%29.svg/560px-Copy_galloping_mode_timsort%282%29.svg.png",alt:"Algorithm Visualization"})}),"\n",(0,r.jsx)(t.h2,{id:"complexity",children:"Complexity"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Best"}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Average"}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Worst"}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Memory"}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Stable"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Comments"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Bucket sort"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:"n"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:"n*log(n)"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:"n*log(n)"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:"1"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:"Yes"}),(0,r.jsx)(t.td,{style:{textAlign:"left"}})]})})]}),"\n",(0,r.jsx)(t.h2,{id:"implementations",children:"Implementations"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://github.com/mziccard/node-timsort",children:"mziccard/node-timsort"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://github.com/bellbind/stepbystep-timsort",children:"bellbind/stepbystep-timsort"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://github.com/Scipion/interesting-javascript-codes",children:"Scipion/interesting-javascript-codes"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://www.geeksforgeeks.org/timsort/",children:"Geeksforgeeks"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Timsort",children:"Wikipedia"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://www.youtube.com/watch?v=jVXsjswWo44&ab_channel=MarkLee",children:"YouTube"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://hackernoon.com/timsort-the-fastest-sorting-algorithm-youve-never-heard-of-36b28417f399",children:"HackerNoon"})}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>l});var i=n(6540);const r={},s=i.createContext(r);function o(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);