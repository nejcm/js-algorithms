"use strict";(self.webpackChunk_nejcm_js_algorithms=self.webpackChunk_nejcm_js_algorithms||[]).push([[6054],{8453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>o});var n=i(6540);const r={},s=n.createContext(r);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(s.Provider,{value:t},e.children)}},9953:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>n,toc:()=>m});const n=JSON.parse('{"id":"Algorithms/Graph/Prim","title":"Prim\'s Algorithm","description":"View the implementation","source":"@site/docs/Algorithms/Graph/Prim.mdx","sourceDirName":"Algorithms/Graph","slug":"/Algorithms/Graph/Prim","permalink":"/js-algorithms/docs/Algorithms/Graph/Prim","draft":false,"unlisted":false,"editUrl":"https://github.com/nejcm/js-algorithms/edit/main/docs/Algorithms/Graph/Prim.mdx","tags":[],"version":"current","frontMatter":{"name":"Prim","route":"/algorithms/graph/prim","menu":"Graph"},"sidebar":"tutorialSidebar","previous":{"title":"Kruskal\'s Algorithm","permalink":"/js-algorithms/docs/Algorithms/Graph/Kruskal"},"next":{"title":"Strongly Connected Components","permalink":"/js-algorithms/docs/Algorithms/Graph/StronglyConnectedComponents"}}');var r=i(4848),s=i(8453);const a={name:"Prim",route:"/algorithms/graph/prim",menu:"Graph"},o="Prim's Algorithm",h={},m=[{value:"Minimum Spanning Tree",id:"minimum-spanning-tree",level:2},{value:"Complexity",id:"complexity",level:2},{value:"References",id:"references",level:2}];function l(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"prims-algorithm",children:"Prim's Algorithm"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://github.com/nejcm/js-algorithms/blob/master/src/algorithms/graph/prim/index.ts",children:"View the implementation"})}),"\n",(0,r.jsx)(t.p,{children:"Prim's (also known as Jarn\xedk's) algorithm is a greedy algorithm that finds a minimum\nspanning tree for a weighted undirected graph. This means it finds a subset of the edges\nthat forms a tree that includes every vertex, where the total weight of all the edges in\nthe tree is minimized. The algorithm operates by building this tree one vertex at a time,\nfrom an arbitrary starting vertex, at each step adding the cheapest possible connection\nfrom the tree to another vertex."}),"\n",(0,r.jsx)(t.p,{children:"Other well-known algorithms for this problem include Kruskal's algorithm and Bor\u016fvka's\nalgorithm. These algorithms find the minimum spanning forest in a possibly disconnected\ngraph; in contrast, the most basic form of Prim's algorithm only finds minimum spanning\ntrees in connected graphs. However, running Prim's algorithm separately for each connected\ncomponent of the graph, it can also be used to find the minimum spanning forest. In terms\nof their asymptotic time complexity, these three algorithms are equally fast for sparse\ngraphs, but slower than other more sophisticated algorithms. However, for graphs that are\nsufficiently dense, Prim's algorithm can be made to run in linear time, meeting or\nimproving the time bounds for other algorithms. [Source: Wikipedia]"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"https://upload.wikimedia.org/wikipedia/commons/f/f7/Prim%27s_algorithm.svg",alt:"Prim's Algorithm"})}),"\n",(0,r.jsx)(t.h2,{id:"minimum-spanning-tree",children:"Minimum Spanning Tree"}),"\n",(0,r.jsx)(t.p,{children:"A minimum spanning tree (MST) or minimum weight spanning tree is a subset of the edges of\na connected, edge-weighted undirected graph that connects all the vertices together,\nwithout any cycles and with the minimum possible total edge weight. That is, it is a\nspanning tree whose sum of edge weights is as small as possible. More generally, any\nedge-weighted undirected graph (not necessarily connected) has a minimum spanning forest,\nwhich is a union of the minimum spanning trees for its connected components. [Source:\nWikipedia]"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Minimum_spanning_tree.svg/600px-Minimum_spanning_tree.svg.png",alt:"Minimum Spanning Tree"})}),"\n",(0,r.jsx)(t.h2,{id:"complexity",children:"Complexity"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Best time"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Comments"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Prim"}),(0,r.jsxs)(t.td,{style:{textAlign:"center"},children:["v",(0,r.jsx)("sup",{children:"2"})]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"The time complexity can be reduced to log(v) with the help of binary heap."})]})})]}),"\n",(0,r.jsx)(t.p,{children:"* Where v = number of vertices; e = number of edges"}),"\n",(0,r.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/",children:"Geeksforgeeks"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Prim%27s_algorithm",children:"Wikipedia"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://www.youtube.com/watch?v=4ZlRH0eK-qQ&ab_channel=AbdulBari",children:"YouTube"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://www.programiz.com/dsa/prim-algorithm",children:"Programiz"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://cp-algorithms.com/graph/mst_prim.html",children:"cp-algorithms"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://www.tutorialspoint.com/data_structures_algorithms/prims_spanning_tree_algorithm.htm",children:"Tutorialspoint"})}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);