"use strict";(self.webpackChunk_nejcm_js_algorithms=self.webpackChunk_nejcm_js_algorithms||[]).push([[229],{7572:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"data-structures/tree","title":"Tree","description":"is a widely used abstract data type (ADT) that simulates a hierarchical tree structure,","source":"@site/docs/data-structures/tree.md","sourceDirName":"data-structures","slug":"/data-structures/tree","permalink":"/js-algorithms/docs/data-structures/tree","draft":false,"unlisted":false,"editUrl":"https://github.com/nejcm/js-algorithms/edit/main/docs/data-structures/tree.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Stack","permalink":"/js-algorithms/docs/data-structures/stack"},"next":{"title":"Trie","permalink":"/js-algorithms/docs/data-structures/trie"}}');var a=r(4848),s=r(8453);const i={sidebar_position:9},l="Tree",o={},c=[{value:"Some tree types:",id:"some-tree-types",level:3},{value:"References",id:"references",level:2}];function d(e){const t={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"tree",children:"Tree"})}),"\n",(0,a.jsx)(t.p,{children:"is a widely used abstract data type (ADT) that simulates a hierarchical tree structure,\nwith a root value and subtrees of children with a parent node, represented as a set of\nlinked nodes."}),"\n",(0,a.jsx)(t.p,{children:'A tree data structure can be defined recursively as a collection of nodes (starting at a\nroot node), where each node is a data structure consisting of a value, together with a\nlist of references to nodes (the "children"), with the constraints that no reference is\nduplicated, and none points to the root.'}),"\n",(0,a.jsx)(t.p,{children:'Alternatively, a tree can be defined abstractly as a whole (globally) as an ordered tree,\nwith a value assigned to each node. Both these perspectives are useful: while a tree can\nbe analyzed mathematically as a whole, when actually represented as a data structure it is\nusually represented and worked with separately by node (rather than as a set of nodes and\nan adjacency list of edges between nodes, as one may represent a digraph, for instance).\nFor example, looking at a tree as a whole, one can talk about "the parent node" of a given\nnode, but in general as a data structure a given node only contains the list of its\nchildren, but does not contain a reference to its parent (if any). (Source: Wikipedia)'}),"\n",(0,a.jsx)(t.h3,{id:"some-tree-types",children:"Some tree types:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Binary Tree"}),": This is the most basic basic from of tree structure. Where each node\ncan have utmost two children. A perfect binary tree is a binary tree in which all\ninterior nodes have two children and all leaves have the same depth or same level. A\nfull binary tree (sometimes referred to as a proper or plane binary tree) is a tree in\nwhich every node in the tree has either 0 or 2 children. In a complete binary tree\nevery level, except possibly the last, is completely filled, and all nodes in the last\nlevel are as far left as possible. In the infinite complete binary tree, every node has\ntwo children."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Binary search tree"}),": BST is a binary tree with certain properties such as , and left\nchild of the given node contains value less than equal to the given node and right hand\nchild contain node greater than the given node."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"AVL tree or height balanced binary tree"}),": It is a variation of the Binary tree where\nheight difference between left and right sub tree can be at most 1. If at any time they\ndiffer by more than one, rebalancing is done to restore this property. Lookup,\ninsertion, and deletion all take O(log n) time in both the average and worst cases,\nwhere n is the number of nodes in the tree prior to the operation."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Red-Black tree"}),": Another variant of binary tree similar to AVL tree it is a self\nbalancing binary search tree. In this tree nodes are either colored red or black."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Splay tree"}),": A splay tree is a self-adjusting binary search tree with the additional\nproperty that recently accessed elements are quick to access again. All normal\noperations on a binary search tree are combined with one basic operation, called\nsplaying. Splaying the tree for a certain element rearranges the tree so that the\nelement is placed at the root of the tree."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"N-ary tree"}),": In this tree the limitation of the binary tree is removed. Here a node\ncan have at most n children. Like binary tree it can be full,complete or perfect n-ary\ntree. N-ary is some time known as forest."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Fenwick tree"}),": Is a binary indexed tree is a data structure that can efficiently\nupdate elements and calculate prefix sums in a table of numbers."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Trie Structure"}),": In computer science, a trie, also called digital tree and sometimes\nradix tree or prefix tree (as they can be searched by prefixes), is an ordered tree\ndata structure that is used to store a dynamic set or associative array where the keys\nare usually strings. All the descendants of a node have a common prefix of the string\nassociated with that node, and the root is associated with the empty string."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Suffix tree"}),": Trie and suffix tree are closely related. a suffix tree (also called\nPAT tree or, in an earlier form, position tree) is a compressed trie containing all the\nsuffixes of the given text as their keys and positions in the text as their values.\nSuffix trees allow particularly fast implementations of many important string\noperations."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Huffman Tree"}),": Huffman tree is a frequency sorted binary tree used widely in\ncompressing data. Huffman tree is constructed to allocate a short code word to a long\ntext based on its frequency of occurrences."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Heap Structure"}),": Heap structure is another widely used tree structure with a\nspecific ordering property. There are two types of heap - Min heap and Max heap. In a\nmin heap the parent of a node must be smaller than the values of all its children.\nSimilarly in max heap the parent always have greater value compared to all its\nchildren. One common implementation of heap is Binary heap where each parent can have\nat most two children."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:"https://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_tree.svg",alt:"Data Structure Visualization"})}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Operation"}),(0,a.jsx)(t.th,{style:{textAlign:"center"},children:"Best Case Complexity"}),(0,a.jsx)(t.th,{style:{textAlign:"center"},children:"Average Case Complexity"}),(0,a.jsx)(t.th,{style:{textAlign:"center"},children:"Worst Case Complexity"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Search"}),(0,a.jsx)(t.td,{style:{textAlign:"center"},children:"O(log n)"}),(0,a.jsx)(t.td,{style:{textAlign:"center"},children:"O(log n)"}),(0,a.jsx)(t.td,{style:{textAlign:"center"},children:"O(n)"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Insertion"}),(0,a.jsx)(t.td,{style:{textAlign:"center"},children:"O(log n)"}),(0,a.jsx)(t.td,{style:{textAlign:"center"},children:"O(log n)"}),(0,a.jsx)(t.td,{style:{textAlign:"center"},children:"O(n)"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Deletion"}),(0,a.jsx)(t.td,{style:{textAlign:"center"},children:"O(log n)"}),(0,a.jsx)(t.td,{style:{textAlign:"center"},children:"O(log n)"}),(0,a.jsx)(t.td,{style:{textAlign:"center"},children:"O(n)"})]})]})]}),"\n",(0,a.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://www.geeksforgeeks.org/binary-tree-data-structure/",children:"Geeksforgeeks"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Tree_(data_structure)",children:"Wikipedia"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://www.youtube.com/watch?v=oSWTXtMglKE",children:"YouTube"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://www.programiz.com/dsa/trees",children:"Programiz"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/tutorial/",children:"Hackerearth"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://www.tutorialspoint.com/data_structures_algorithms/tree_data_structure.htm",children:"Tutorialspoint"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>l});var n=r(6540);const a={},s=n.createContext(a);function i(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);