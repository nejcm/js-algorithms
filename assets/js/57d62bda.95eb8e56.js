"use strict";(self.webpackChunk_nejcm_js_algorithms=self.webpackChunk_nejcm_js_algorithms||[]).push([[7696],{6496:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>h,contentTitle:()=>d,default:()=>o,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"data-structures/heap","title":"Heap","description":"Is a specialized tree-based data structure which is essentially an almost complete tree","source":"@site/docs/data-structures/heap.md","sourceDirName":"data-structures","slug":"/data-structures/heap","permalink":"/js-algorithms/docs/data-structures/heap","draft":false,"unlisted":false,"editUrl":"https://github.com/nejcm/js-algorithms/edit/main/docs/data-structures/heap.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Hash table","permalink":"/js-algorithms/docs/data-structures/hash-table"},"next":{"title":"Linked list","permalink":"/js-algorithms/docs/data-structures/linked-list"}}');var n=s(4848),i=s(8453);const a={sidebar_position:4},d="Heap",h={},l=[{value:"References",id:"references",level:2}];function c(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"heap",children:"Heap"})}),"\n",(0,n.jsx)(t.p,{children:'Is a specialized tree-based data structure which is essentially an almost complete tree\nthat satisfies the heap property: in a max heap, for any given node C, if P is a parent\nnode of C, then the key (the value) of P is greater than or equal to the key of C. In a\nmin heap, the key of P is less than or equal to the key of C. The node at the "top" of the\nheap (with no parents) is called the root node.'}),"\n",(0,n.jsx)(t.p,{children:'The heap is one maximally efficient implementation of an abstract data type called a\npriority queue, and in fact, priority queues are often referred to as "heaps", regardless\nof how they may be implemented. In a heap, the highest (or lowest) priority element is\nalways stored at the root. However, a heap is not a sorted structure; it can be regarded\nas being partially ordered. A heap is a useful data structure when it is necessary to\nrepeatedly remove the object with the highest (or lowest) priority.'}),"\n",(0,n.jsx)(t.p,{children:"A common implementation of a heap is the binary heap, in which the tree is a binary tree\n(see figure). The heap data structure, specifically the binary heap, was introduced by J.\nW. J. Williams in 1964, as a data structure for the heapsort sorting algorithm. Heaps are\nalso crucial in several efficient graph algorithms such as Dijkstra's algorithm. When a\nheap is a complete binary tree, it has a smallest possible height\u2014a heap with N nodes and\nfor each node a branches always has loga N height. (Source: Wikipedia)"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:"https://www.geeksforgeeks.org/wp-content/uploads/MinHeapAndMaxHeap.png",alt:"Heap Visualization"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Types of heaps:"})}),"\n",(0,n.jsx)(t.p,{children:"There are several different types of heaps, each with a different implementation and\nvarious advantages and disadvantages. However, each heap type satisfies the heap property\nand can be used for the same types of tasks."}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Operation"}),(0,n.jsx)(t.th,{children:"find-min"}),(0,n.jsx)(t.th,{children:"delete-min"}),(0,n.jsx)(t.th,{children:"insert"}),(0,n.jsx)(t.th,{children:"decrease-key"}),(0,n.jsx)(t.th,{children:"meld"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Binary"}),(0,n.jsx)(t.td,{children:"\u0398(1)"}),(0,n.jsx)(t.td,{children:"\u0398(log n)"}),(0,n.jsx)(t.td,{children:"O(log n)"}),(0,n.jsx)(t.td,{children:"O(log n)"}),(0,n.jsx)(t.td,{children:"\u0398(n)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Leftist"}),(0,n.jsx)(t.td,{children:"\u0398(1)"}),(0,n.jsx)(t.td,{children:"\u0398(log n)"}),(0,n.jsx)(t.td,{children:"\u0398(log n)"}),(0,n.jsx)(t.td,{children:"O(log n)"}),(0,n.jsx)(t.td,{children:"\u0398(log n)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Binomial"}),(0,n.jsx)(t.td,{children:"\u0398(1)"}),(0,n.jsx)(t.td,{children:"\u0398(log n)"}),(0,n.jsx)(t.td,{children:"\u0398(1)*"}),(0,n.jsx)(t.td,{children:"\u0398(log n)"}),(0,n.jsx)(t.td,{children:"O(log n)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Fibonacci"}),(0,n.jsx)(t.td,{children:"\u0398(1)"}),(0,n.jsx)(t.td,{children:"O(log n)*"}),(0,n.jsx)(t.td,{children:"\u0398(1)"}),(0,n.jsx)(t.td,{children:"\u0398(1)*"}),(0,n.jsx)(t.td,{children:"\u0398(1)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Pairing"}),(0,n.jsx)(t.td,{children:"\u0398(1)"}),(0,n.jsx)(t.td,{children:"O(log n)*"}),(0,n.jsx)(t.td,{children:"\u0398(1)"}),(0,n.jsx)(t.td,{children:"o(log n)*"}),(0,n.jsx)(t.td,{children:"\u0398(1)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Brodal"}),(0,n.jsx)(t.td,{children:"\u0398(1)"}),(0,n.jsx)(t.td,{children:"O(log n)"}),(0,n.jsx)(t.td,{children:"\u0398(1)"}),(0,n.jsx)(t.td,{children:"\u0398(1)"}),(0,n.jsx)(t.td,{children:"\u0398(1)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Rank-pairing"}),(0,n.jsx)(t.td,{children:"\u0398(1)"}),(0,n.jsx)(t.td,{children:"O(log n)*"}),(0,n.jsx)(t.td,{children:"\u0398(1)"}),(0,n.jsx)(t.td,{children:"\u0398(1)*"}),(0,n.jsx)(t.td,{children:"\u0398(1)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Strict Fibonacci"}),(0,n.jsx)(t.td,{children:"\u0398(1)"}),(0,n.jsx)(t.td,{children:"O(log n)"}),(0,n.jsx)(t.td,{children:"\u0398(1)"}),(0,n.jsx)(t.td,{children:"\u0398(1)"}),(0,n.jsx)(t.td,{children:"\u0398(1)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"2-3 heap"}),(0,n.jsx)(t.td,{children:"O(log n)"}),(0,n.jsx)(t.td,{children:"O(log n)*"}),(0,n.jsx)(t.td,{children:"O(log n)*"}),(0,n.jsx)(t.td,{children:"\u0398(1)"}),(0,n.jsx)(t.td,{children:"?"})]})]})]}),"\n",(0,n.jsx)(t.p,{children:"* Amortized time"}),"\n",(0,n.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://www.geeksforgeeks.org/heap-data-structure/",children:"Geeksforgeeks"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Heap_(data_structure)",children:"Wikipedia"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://www.youtube.com/watch?v=t0Cq6tVNRBA",children:"YouTube"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://www.programiz.com/dsa/heap-data-structure",children:"Programiz"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://www.hackerearth.com/practice/data-structures/trees/heapspriority-queues/tutorial/",children:"Hackerearth"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://www.tutorialspoint.com/data_structures_algorithms/heap_data_structure.htm",children:"Tutorialspoint"})}),"\n"]})]})}function o(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>d});var r=s(6540);const n={},i=r.createContext(n);function a(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);