"use strict";(self.webpackChunk_nejcm_js_algorithms=self.webpackChunk_nejcm_js_algorithms||[]).push([[9468],{4847:(t,e,r)=>{r.r(e),r.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Algorithms/Sorting/QuickSort","title":"Quick Sort","description":"View the implementation","source":"@site/docs/Algorithms/Sorting/QuickSort.mdx","sourceDirName":"Algorithms/Sorting","slug":"/Algorithms/Sorting/QuickSort","permalink":"/js-algorithms/docs/Algorithms/Sorting/QuickSort","draft":false,"unlisted":false,"editUrl":"https://github.com/nejcm/js-algorithms/edit/main/docs/Algorithms/Sorting/QuickSort.mdx","tags":[],"version":"current","frontMatter":{"name":"Quick sort","route":"/algorithms/sorting/quick-sort","menu":"Sorting"},"sidebar":"tutorialSidebar","previous":{"title":"Merge Sort","permalink":"/js-algorithms/docs/Algorithms/Sorting/MergeSort"},"next":{"title":"Radix Sort","permalink":"/js-algorithms/docs/Algorithms/Sorting/RadixSort"}}');var n=r(4848),s=r(8453);const o={name:"Quick sort",route:"/algorithms/sorting/quick-sort",menu:"Sorting"},l="Quick Sort",a={},c=[{value:"Complexity",id:"complexity",level:2},{value:"References",id:"references",level:2}];function h(t){const e={a:"a",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.header,{children:(0,n.jsx)(e.h1,{id:"quick-sort",children:"Quick Sort"})}),"\n",(0,n.jsx)(e.p,{children:(0,n.jsx)(e.a,{href:"https://github.com/nejcm/js-algorithms/blob/master/src/algorithms/sorting/quick-sort/index.ts",children:"View the implementation"})}),"\n",(0,n.jsx)(e.p,{children:"Quicksort (sometimes called partition-exchange sort) is an efficient sorting algorithm.\nWhen implemented well, it can be about two or three times faster than its main\ncompetitors, merge sort and heapsort."}),"\n",(0,n.jsx)(e.p,{children:"Quicksort is a divide-and-conquer algorithm. It works by selecting a 'pivot' element from\nthe array and partitioning the other elements into two sub-arrays, according to whether\nthey are less than or greater than the pivot. The sub-arrays are then sorted recursively.\nThis can be done in-place, requiring small additional amounts of memory to perform the\nsorting."}),"\n",(0,n.jsx)(e.p,{children:'Quicksort is a comparison sort, meaning that it can sort items of any type for which a\n"less-than" relation (formally, a total order) is defined. Efficient implementations of\nQuicksort are not a stable sort, meaning that the relative order of equal sort items is\nnot preserved.'}),"\n",(0,n.jsx)(e.p,{children:"Animated visualization of the quicksort algorithm. The horizontal lines are pivot values."}),"\n",(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:"https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif",alt:"Quicksort"})}),"\n",(0,n.jsx)(e.h2,{id:"complexity",children:"Complexity"}),"\n",(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:"Name"}),(0,n.jsx)(e.th,{style:{textAlign:"center"},children:"Best"}),(0,n.jsx)(e.th,{style:{textAlign:"center"},children:"Average"}),(0,n.jsx)(e.th,{style:{textAlign:"center"},children:"Worst"}),(0,n.jsx)(e.th,{style:{textAlign:"center"},children:"Memory"}),(0,n.jsx)(e.th,{style:{textAlign:"center"},children:"Stable"}),(0,n.jsx)(e.th,{style:{textAlign:"left"},children:"Comments"})]})}),(0,n.jsx)(e.tbody,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:"Quick sort"}),(0,n.jsx)(e.td,{style:{textAlign:"center"},children:"n*log(n)"}),(0,n.jsx)(e.td,{style:{textAlign:"center"},children:"n*log(n)"}),(0,n.jsxs)(e.td,{style:{textAlign:"center"},children:["n",(0,n.jsx)("sup",{children:"2"})]}),(0,n.jsx)(e.td,{style:{textAlign:"center"},children:"log(n)"}),(0,n.jsx)(e.td,{style:{textAlign:"center"},children:"No"}),(0,n.jsx)(e.td,{style:{textAlign:"left"},children:"Quicksort is usually done in-place with O(log(n)) stack space"})]})})]}),"\n",(0,n.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,n.jsxs)(e.ul,{children:["\n",(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:"https://www.geeksforgeeks.org/quick-sort/",children:"Geeksforgeeks"})}),"\n",(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:"https://en.wikipedia.org/wiki/Quicksort",children:"Wikipedia"})}),"\n",(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:"https://www.youtube.com/watch?v=SLauY6PpjW4",children:"YouTube"})}),"\n",(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:"https://www.programiz.com/dsa/quick-sort",children:"Programiz"})}),"\n",(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:"http://www.algomation.com/player?algorithm=58bb2ef75b2b830400b05118",children:"Algomation"})}),"\n",(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:"https://www.hackerearth.com/practice/algorithms/sorting/quick-sort/tutorial/",children:"Hackerearth"})}),"\n",(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:"https://www.tutorialspoint.com/data_structures_algorithms/quick_sort_algorithm.htm",children:"Tutorialspoint"})}),"\n"]})]})}function d(t={}){const{wrapper:e}={...(0,s.R)(),...t.components};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(h,{...t})}):h(t)}},8453:(t,e,r)=>{r.d(e,{R:()=>o,x:()=>l});var i=r(6540);const n={},s=i.createContext(n);function o(t){const e=i.useContext(s);return i.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function l(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(n):t.components||n:o(t.components),i.createElement(s.Provider,{value:e},t.children)}}}]);