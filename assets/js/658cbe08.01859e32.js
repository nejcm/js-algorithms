"use strict";(self.webpackChunk_nejcm_js_algorithms=self.webpackChunk_nejcm_js_algorithms||[]).push([[9512],{66:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"Algorithms/Graph/Kruskal","title":"Kruskal\'s Algorithm","description":"View the implementation","source":"@site/docs/Algorithms/Graph/Kruskal.mdx","sourceDirName":"Algorithms/Graph","slug":"/Algorithms/Graph/Kruskal","permalink":"/js-algorithms/docs/Algorithms/Graph/Kruskal","draft":false,"unlisted":false,"editUrl":"https://github.com/nejcm/js-algorithms/edit/main/docs/Algorithms/Graph/Kruskal.mdx","tags":[],"version":"current","frontMatter":{"name":"Kruskal","route":"/algorithms/graph/kruskal","menu":"Graph"},"sidebar":"tutorialSidebar","previous":{"title":"Hamiltonian Cycle","permalink":"/js-algorithms/docs/Algorithms/Graph/HamiltonianCycle"},"next":{"title":"Prim\'s Algorithm","permalink":"/js-algorithms/docs/Algorithms/Graph/Prim"}}');var i=r(4848),n=r(8453);const l={name:"Kruskal",route:"/algorithms/graph/kruskal",menu:"Graph"},a="Kruskal's Algorithm",h={},o=[{value:"Complexity",id:"complexity",level:2},{value:"References",id:"references",level:2}];function c(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"kruskals-algorithm",children:"Kruskal's Algorithm"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/nejcm/js-algorithms/blob/master/src/algorithms/graph/kruskal/index.ts",children:"View the implementation"})}),"\n",(0,i.jsx)(t.p,{children:"Kruskal's algorithm is a minimum-spanning-tree algorithm which finds an edge of the least\npossible weight that connects any two trees in the forest. It is a greedy algorithm in\ngraph theory as it finds a minimum spanning tree for a connected weighted graph adding\nincreasing cost arcs at each step. This means it finds a subset of the edges that forms a\ntree that includes every vertex, where the total weight of all the edges in the tree is\nminimized. If the graph is not connected, then it finds a minimum spanning forest (a\nminimum spanning tree for each connected component). [Source: Wikipedia]"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:"https://upload.wikimedia.org/wikipedia/commons/thumb/5/5c/MST_kruskal_en.gif/600px-MST_kruskal_en.gif",alt:"Kruskal Algorithm"})}),"\n",(0,i.jsx)(t.h2,{id:"complexity",children:"Complexity"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"Best time"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Comments"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Kruskal"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"v * log(v)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"}})]})})]}),"\n",(0,i.jsx)(t.p,{children:"* Where v = number of vertices; e = number of edges"}),"\n",(0,i.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/",children:"Geeksforgeeks"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Kruskal%27s_algorithm",children:"Wikipedia"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://www.youtube.com/watch?v=4ZlRH0eK-qQ&t=700s&ab_channel=AbdulBari",children:"YouTube"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://www.programiz.com/dsa/kruskal-algorithm",children:"Programiz"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://cp-algorithms.com/graph/mst_kruskal.html",children:"cp-algorithms"})}),"\n"]})]})}function m(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>l,x:()=>a});var s=r(6540);const i={},n=s.createContext(i);function l(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);