"use strict";(self.webpackChunk_nejcm_js_algorithms=self.webpackChunk_nejcm_js_algorithms||[]).push([[3412],{8453:(e,t,n)=>{n.d(t,{R:()=>h,x:()=>l});var r=n(6540);const i={},s=r.createContext(i);function h(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:h(e.components),r.createElement(s.Provider,{value:t},e.children)}},9036:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>h,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"Algorithms/Pattern/ZAlgorithm","title":"Z Algorithm","description":"View the implementation","source":"@site/docs/Algorithms/Pattern/ZAlgorithm.mdx","sourceDirName":"Algorithms/Pattern","slug":"/Algorithms/Pattern/ZAlgorithm","permalink":"/js-algorithms/docs/Algorithms/Pattern/ZAlgorithm","draft":false,"unlisted":false,"editUrl":"https://github.com/nejcm/js-algorithms/edit/main/docs/Algorithms/Pattern/ZAlgorithm.mdx","tags":[],"version":"current","frontMatter":{"name":"Z algorithm","route":"/algorithms/pattern/z-algorithm","menu":"Pattern"},"sidebar":"tutorialSidebar","previous":{"title":"Rabin Karp","permalink":"/js-algorithms/docs/Algorithms/Pattern/RabinKarp"},"next":{"title":"Binary search","permalink":"/js-algorithms/docs/Algorithms/Searching/BinarySearch"}}');var i=n(4848),s=n(8453);const h={name:"Z algorithm",route:"/algorithms/pattern/z-algorithm",menu:"Pattern"},l="Z Algorithm",o={},c=[{value:"Complexity",id:"complexity",level:2},{value:"References",id:"references",level:2}];function a(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"z-algorithm",children:"Z Algorithm"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/nejcm/js-algorithms/blob/master/src/algorithms/pattern/z-algorithm/index.ts",children:"View the implementation"})}),"\n",(0,i.jsxs)(t.p,{children:['The Z-algorithm finds occurrences of a "word" ',(0,i.jsx)(t.code,{children:"W"}),' within a main "text string" ',(0,i.jsx)(t.code,{children:"T"})," in\nlinear time ",(0,i.jsx)(t.code,{children:"O(|W| + |T|)"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Given a string ",(0,i.jsx)(t.code,{children:"S"})," of length ",(0,i.jsx)(t.code,{children:"n"}),", the algorithm produces an array, ",(0,i.jsx)(t.code,{children:"Z"})," where ",(0,i.jsx)(t.code,{children:"Z[i]"}),"\nrepresents the longest substring starting from ",(0,i.jsx)(t.code,{children:"S[i]"})," which is also a prefix of ",(0,i.jsx)(t.code,{children:"S"}),".\nFinding ",(0,i.jsx)(t.code,{children:"Z"})," for the string obtained by concatenating the word, ",(0,i.jsx)(t.code,{children:"W"})," with a nonce character,\nsay ",(0,i.jsx)(t.code,{children:"$"})," followed by the text, ",(0,i.jsx)(t.code,{children:"T"}),", helps with pattern matching, for if there is some index\n",(0,i.jsx)(t.code,{children:"i"})," such that ",(0,i.jsx)(t.code,{children:"Z[i]"})," equals the pattern length, then the pattern must be present at that\npoint."]}),"\n",(0,i.jsxs)(t.p,{children:["While the ",(0,i.jsx)(t.code,{children:"Z"})," array can be computed with two nested loops in ",(0,i.jsx)(t.code,{children:"O(|W| * |T|)"})," time, the\nfollowing strategy shows how to obtain it in linear time, based on the idea that as we\niterate over the letters in the string (index ",(0,i.jsx)(t.code,{children:"i"})," from ",(0,i.jsx)(t.code,{children:"1"})," to ",(0,i.jsx)(t.code,{children:"n - 1"}),"), we maintain an\ninterval ",(0,i.jsx)(t.code,{children:"[L, R]"})," which is the interval with maximum ",(0,i.jsx)(t.code,{children:"R"})," such that ",(0,i.jsx)(t.code,{children:"1 \u2264 L \u2264 i \u2264 R"})," and\n",(0,i.jsx)(t.code,{children:"S[L...R]"})," is a prefix that is also a substring (if no such interval exists, just let\n",(0,i.jsx)(t.code,{children:"L = R = - 1"}),"). For ",(0,i.jsx)(t.code,{children:"i = 1"}),", we can simply compute ",(0,i.jsx)(t.code,{children:"L"})," and ",(0,i.jsx)(t.code,{children:"R"})," by comparing ",(0,i.jsx)(t.code,{children:"S[0...]"})," to\n",(0,i.jsx)(t.code,{children:"S[1...]"}),". (Source: Wikipedia)"]}),"\n",(0,i.jsx)(t.h2,{id:"complexity",children:"Complexity"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Name"}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"Preprocessing"}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"Average"}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"Worst"}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"Space"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Comments"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Z algorithm"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"m"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"n + m"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"n * m"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"m"}),(0,i.jsx)(t.td,{style:{textAlign:"left"}})]})})]}),"\n",(0,i.jsx)(t.p,{children:"* Where n = length of the source; m = length of the query pattern; k = size of the\nAlphabet"}),"\n",(0,i.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/",children:"Geeksforgeeks"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://www.hackerearth.com/practice/algorithms/string-algorithm/z-algorithm/tutorial/",children:"Hackerearth"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://ivanyu.me/blog/2013/10/15/z-algorithm/",children:"Z Algorithm by Ivan Yurchenko"})}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}}}]);