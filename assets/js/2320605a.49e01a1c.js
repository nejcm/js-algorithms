"use strict";(self.webpackChunk_nejcm_js_algorithms=self.webpackChunk_nejcm_js_algorithms||[]).push([[712],{5880:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>o,contentTitle:()=>h,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"Algorithms/Graph/BFS&DFS","title":"BFS & DFS","description":"View the implementation","source":"@site/docs/Algorithms/Graph/BFS&DFS.mdx","sourceDirName":"Algorithms/Graph","slug":"/Algorithms/Graph/BFS&DFS","permalink":"/js-algorithms/docs/Algorithms/Graph/BFS&DFS","draft":false,"unlisted":false,"editUrl":"https://github.com/nejcm/js-algorithms/edit/main/docs/Algorithms/Graph/BFS&DFS.mdx","tags":[],"version":"current","frontMatter":{"name":"Graph BFS & DFS","route":"/algorithms/graph/bfs-dfs","menu":"Graph"},"sidebar":"tutorialSidebar","previous":{"title":"Articulation Points","permalink":"/js-algorithms/docs/Algorithms/Graph/ArticulationPoints"},"next":{"title":"Bellman Ford","permalink":"/js-algorithms/docs/Algorithms/Graph/BellmanFord"}}');var i=t(4848),n=t(8453);const a={name:"Graph BFS & DFS",route:"/algorithms/graph/bfs-dfs",menu:"Graph"},h="BFS & DFS",o={},l=[{value:"Breadth first search",id:"breadth-first-search",level:2},{value:"Depth first search",id:"depth-first-search",level:2},{value:"References",id:"references",level:2},{value:"BFS",id:"bfs",level:3},{value:"DFS",id:"dfs",level:3}];function c(e){const r={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"bfs--dfs",children:"BFS & DFS"})}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.a,{href:"https://github.com/nejcm/js-algorithms/blob/master/src/algorithms/graph/bfs-dfs/index.ts",children:"View the implementation"})}),"\n",(0,i.jsx)(r.h2,{id:"breadth-first-search",children:"Breadth first search"}),"\n",(0,i.jsx)(r.p,{children:"BFS (level order traversal) is a vertex based technique for finding a shortest path in\ngraph. It uses a Queue data structure which follows first in first out. In BFS, one vertex\nis selected at a time when it is visited and marked then its adjacent are visited and\nstored in the queue. It is slower than DFS. [Source: Geeksforgeeks]"}),"\n",(0,i.jsx)(r.p,{children:"It starts traversing from a selected node (source or starting node) and traverse the graph\nlayerwise thus exploring the neighbour nodes (nodes which are directly connected to source\nnode). You must then move towards the next-level neighbour nodes."}),"\n",(0,i.jsx)(r.h2,{id:"depth-first-search",children:"Depth first search"}),"\n",(0,i.jsx)(r.p,{children:"DFS is a edge based technique. It uses the Stack data structure, performs two stages,\nfirst visited vertices are pushed into stack and second if there is no vertices then\nvisited vertices are popped."}),"\n",(0,i.jsx)(r.p,{children:"The DFS algorithm is a recursive algorithm that uses the idea of backtracking. It involves\nexhaustive searches of all the nodes by going ahead, if possible, else by backtracking."}),"\n",(0,i.jsx)(r.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/",children:"Geeksforgeeks"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.youtube.com/watch?v=pcKY4hjDrxk",children:"YouTube"})}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"bfs",children:"BFS"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/",children:"Geeksforgeeks"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Breadth-first_search",children:"Wikipedia"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.hackerearth.com/practice/algorithms/graphs/breadth-first-search/tutorial/",children:"Hackerearth"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.tutorialspoint.com/data_structures_algorithms/breadth_first_traversal.htm",children:"Tutorialspoint"})}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"dfs",children:"DFS"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/",children:"Geeksforgeeks"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Depth-first_search",children:"Wikipedia"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.hackerearth.com/practice/algorithms/graphs/depth-first-search/tutorial/",children:"Hackerearth"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.tutorialspoint.com/data_structures_algorithms/depth_first_traversal.htm",children:"Tutorialspoint"})}),"\n"]})]})}function d(e={}){const{wrapper:r}={...(0,n.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,r,t)=>{t.d(r,{R:()=>a,x:()=>h});var s=t(6540);const i={},n=s.createContext(i);function a(e){const r=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function h(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(n.Provider,{value:r},e.children)}}}]);