"use strict";(self.webpackChunk_nejcm_js_algorithms=self.webpackChunk_nejcm_js_algorithms||[]).push([[5231],{7623:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>o,contentTitle:()=>h,default:()=>l,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Algorithms/Tree/BFS&DFS","title":"BFS & DFS","description":"Breadth first search","source":"@site/docs/Algorithms/Tree/BFS&DFS.mdx","sourceDirName":"Algorithms/Tree","slug":"/Algorithms/Tree/BFS&DFS","permalink":"/js-algorithms/docs/Algorithms/Tree/BFS&DFS","draft":false,"unlisted":false,"editUrl":"https://github.com/nejcm/js-algorithms/edit/main/docs/Algorithms/Tree/BFS&DFS.mdx","tags":[],"version":"current","frontMatter":{"name":"Tree BFS & DFS","route":"/algorithms/tree/bfs-dfs","menu":"Tree"},"sidebar":"tutorialSidebar","previous":{"title":"Levenshtein distance","permalink":"/js-algorithms/docs/Algorithms/String/LevenshteinDistance"},"next":{"title":"Knapsack problem","permalink":"/js-algorithms/docs/Algorithms/Other/KnapsackProblem"}}');var i=s(4848),n=s(8453);const a={name:"Tree BFS & DFS",route:"/algorithms/tree/bfs-dfs",menu:"Tree"},h="BFS & DFS",o={},c=[{value:"Breadth first search",id:"breadth-first-search",level:2},{value:"Depth first search",id:"depth-first-search",level:2},{value:"References",id:"references",level:2},{value:"BFS",id:"bfs",level:3},{value:"DFS",id:"dfs",level:3}];function d(e){const r={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"bfs--dfs",children:"BFS & DFS"})}),"\n",(0,i.jsx)(r.h2,{id:"breadth-first-search",children:"Breadth first search"}),"\n",(0,i.jsx)(r.p,{children:"BFS (level order traversal) is a vertex based technique for finding a shortest path in\ntree. It uses a Queue data structure which follows first in first out. In BFS, one node is\nselected at a time when it is visited and marked then its adjacent are visited and stored\nin the queue. It is slower than DFS. [Source: Geeksforgeeks]"}),"\n",(0,i.jsx)(r.p,{children:"It starts traversing from a selected node (source or starting node) and traverse the tree\nlayerwise thus exploring the neighbour nodes (nodes which are directly connected to source\nnode). You must then move towards the next-level neighbour nodes."}),"\n",(0,i.jsx)(r.h2,{id:"depth-first-search",children:"Depth first search"}),"\n",(0,i.jsx)(r.p,{children:"DFS is a edge based technique. It uses the Stack data structure, performs two stages,\nfirst visited nodes are pushed into stack and second if there is no node then visited\nnodes are popped."}),"\n",(0,i.jsx)(r.p,{children:"The DFS algorithm is a recursive algorithm that uses the idea of backtracking. It involves\nexhaustive searches of all the nodes by going ahead, if possible, else by backtracking."}),"\n",(0,i.jsx)(r.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/",children:"Geeksforgeeks"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.youtube.com/watch?v=pcKY4hjDrxk",children:"YouTube"})}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"bfs",children:"BFS"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/",children:"Geeksforgeeks"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Breadth-first_search",children:"Wikipedia"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.hackerearth.com/practice/algorithms/graphs/breadth-first-search/tutorial/",children:"Hackerearth"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.tutorialspoint.com/data_structures_algorithms/breadth_first_traversal.htm",children:"Tutorialspoint"})}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"dfs",children:"DFS"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/",children:"Geeksforgeeks"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Depth-first_search",children:"Wikipedia"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.hackerearth.com/practice/algorithms/graphs/depth-first-search/tutorial/",children:"Hackerearth"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.tutorialspoint.com/data_structures_algorithms/depth_first_traversal.htm",children:"Tutorialspoint"})}),"\n"]})]})}function l(e={}){const{wrapper:r}={...(0,n.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,r,s)=>{s.d(r,{R:()=>a,x:()=>h});var t=s(6540);const i={},n=t.createContext(i);function a(e){const r=t.useContext(n);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function h(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(n.Provider,{value:r},e.children)}}}]);