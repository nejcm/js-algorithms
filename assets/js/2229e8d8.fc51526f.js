"use strict";(self.webpackChunk_nejcm_js_algorithms=self.webpackChunk_nejcm_js_algorithms||[]).push([[8815],{6574:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"Algorithms/Sorting/CountingSort","title":"Counting Sort","description":"View the implementation","source":"@site/docs/Algorithms/Sorting/CountingSort.mdx","sourceDirName":"Algorithms/Sorting","slug":"/Algorithms/Sorting/CountingSort","permalink":"/js-algorithms/docs/Algorithms/Sorting/CountingSort","draft":false,"unlisted":false,"editUrl":"https://github.com/nejcm/js-algorithms/edit/main/docs/Algorithms/Sorting/CountingSort.mdx","tags":[],"version":"current","frontMatter":{"name":"Counting sort","route":"/algorithms/sorting/counting-sort","menu":"Sorting"},"sidebar":"tutorialSidebar","previous":{"title":"Bucket Sort","permalink":"/js-algorithms/docs/Algorithms/Sorting/BucketSort"},"next":{"title":"Heap Sort","permalink":"/js-algorithms/docs/Algorithms/Sorting/HeapSort"}}');var r=n(4848),o=n(8453);const s={name:"Counting sort",route:"/algorithms/sorting/counting-sort",menu:"Sorting"},l="Counting Sort",c={},a=[{value:"Pseudocode",id:"pseudocode",level:2},{value:"Complexity",id:"complexity",level:2},{value:"References",id:"references",level:2}];function h(t){const e={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...t.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"counting-sort",children:"Counting Sort"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://github.com/nejcm/js-algorithms/blob/master/src/algorithms/sorting/counting-sort/index.ts",children:"View the implementation"})}),"\n",(0,r.jsx)(e.p,{children:"In computer science, counting sort is an algorithm for sorting a collection of objects\naccording to keys that are small integers; that is, it is an integer sorting algorithm. It\noperates by counting the number of objects that have each distinct key value, and using\narithmetic on those counts to determine the positions of each key value in the output\nsequence. Its running time is linear in the number of items and the difference between the\nmaximum and minimum key values, so it is only suitable for direct use in situations where\nthe variation in keys is not significantly greater than the number of items. However, it\nis often used as a subroutine in another sorting algorithm, radix sort, that can handle\nlarger keys more efficiently. (Source: Wikipedia)"}),"\n",(0,r.jsx)(e.h2,{id:"pseudocode",children:"Pseudocode"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"count = array of k+1 zeros\nfor x in input do\n    count[key(x)] += 1\n\ntotal = 0\nfor i in 0, 1, ... k do\n    count[i], total = total, count[i] + total\n\noutput = array of the same length as input\nfor x in input do\n    output[count[key(x)]] = x\n    count[key(x)] += 1\n\nreturn output\n"})}),"\n",(0,r.jsx)(e.h2,{id:"complexity",children:"Complexity"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Name"}),(0,r.jsx)(e.th,{style:{textAlign:"center"},children:"Best"}),(0,r.jsx)(e.th,{style:{textAlign:"center"},children:"Average"}),(0,r.jsx)(e.th,{style:{textAlign:"center"},children:"Worst"}),(0,r.jsx)(e.th,{style:{textAlign:"center"},children:"Memory"}),(0,r.jsx)(e.th,{style:{textAlign:"center"},children:"Stable"}),(0,r.jsx)(e.th,{style:{textAlign:"left"},children:"Comments"})]})}),(0,r.jsx)(e.tbody,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Counting sort"}),(0,r.jsx)(e.td,{style:{textAlign:"center"},children:"n+k"}),(0,r.jsx)(e.td,{style:{textAlign:"center"},children:"n+k"}),(0,r.jsx)(e.td,{style:{textAlign:"center"},children:"n+k"}),(0,r.jsx)(e.td,{style:{textAlign:"center"},children:"1"}),(0,r.jsx)(e.td,{style:{textAlign:"center"},children:"Yes"}),(0,r.jsx)(e.td,{style:{textAlign:"left"},children:"n is the number of elements in input array and k is the range of input."})]})})]}),"\n",(0,r.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://www.geeksforgeeks.org/counting-sort/",children:"Geeksforgeeks"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://en.wikipedia.org/wiki/Counting_sort",children:"Wikipedia"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://www.youtube.com/watch?v=7zuGmKfUt7s&ab_channel=GeeksforGeeks",children:"YouTube"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://www.programiz.com/dsa/counting-sort",children:"Programiz"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://www.hackerearth.com/practice/algorithms/sorting/counting-sort/tutorial/",children:"Hackerearth"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://www.tutorialspoint.com/Counting-Sort",children:"Tutorialspoint"})}),"\n"]})]})}function d(t={}){const{wrapper:e}={...(0,o.R)(),...t.components};return e?(0,r.jsx)(e,{...t,children:(0,r.jsx)(h,{...t})}):h(t)}},8453:(t,e,n)=>{n.d(e,{R:()=>s,x:()=>l});var i=n(6540);const r={},o=i.createContext(r);function s(t){const e=i.useContext(o);return i.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function l(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(r):t.components||r:s(t.components),i.createElement(o.Provider,{value:e},t.children)}}}]);