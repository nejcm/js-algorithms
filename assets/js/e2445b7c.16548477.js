"use strict";(self.webpackChunk_nejcm_js_algorithms=self.webpackChunk_nejcm_js_algorithms||[]).push([[3065],{8453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>a});var n=r(6540);const l={},s=n.createContext(l);function i(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),n.createElement(s.Provider,{value:t},e.children)}},8821:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"Algorithms/Graph/BellmanFord","title":"Bellman Ford","description":"View the implementation","source":"@site/docs/Algorithms/Graph/BellmanFord.mdx","sourceDirName":"Algorithms/Graph","slug":"/Algorithms/Graph/BellmanFord","permalink":"/js-algorithms/docs/Algorithms/Graph/BellmanFord","draft":false,"unlisted":false,"editUrl":"https://github.com/nejcm/js-algorithms/edit/main/docs/Algorithms/Graph/BellmanFord.mdx","tags":[],"version":"current","frontMatter":{"name":"Bellman ford","route":"/algorithms/graph/bellman-ford","menu":"Graph"},"sidebar":"tutorialSidebar","previous":{"title":"BFS & DFS","permalink":"/js-algorithms/docs/Algorithms/Graph/BFS&DFS"},"next":{"title":"Bridges","permalink":"/js-algorithms/docs/Algorithms/Graph/Bridges"}}');var l=r(4848),s=r(8453);const i={name:"Bellman ford",route:"/algorithms/graph/bellman-ford",menu:"Graph"},a="Bellman Ford",o={},h=[{value:"Complexity",id:"complexity",level:2},{value:"References",id:"references",level:2}];function c(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(t.header,{children:(0,l.jsx)(t.h1,{id:"bellman-ford",children:"Bellman Ford"})}),"\n",(0,l.jsx)(t.p,{children:(0,l.jsx)(t.a,{href:"https://github.com/nejcm/js-algorithms/blob/master/src/algorithms/graph/bellman-ford/index.ts",children:"View the implementation"})}),"\n",(0,l.jsx)(t.p,{children:"It is an algorithm that computes shortest paths from a single source vertex to all of the\nother vertices in a weighted digraph. It is slower than Dijkstra's algorithm for the same\nproblem, but more versatile, as it is capable of handling graphs in which some of the edge\nweights are negative numbers."}),"\n",(0,l.jsx)(t.p,{children:'Negative edge weights are found in various applications of graphs, hence the usefulness of\nthis algorithm. If a graph contains a "negative cycle" (i.e. a cycle whose edges sum to a\nnegative value) that is reachable from the source, then there is no cheapest path: any\npath that has a point on the negative cycle can be made cheaper by one more walk around\nthe negative cycle. In such a case, the Bellman\u2013Ford algorithm can detect and report the\nnegative cycle.'}),"\n",(0,l.jsx)(t.p,{children:"Like Dijkstra's algorithm, Bellman\u2013Ford proceeds by relaxation, in which approximations to\nthe correct distance are replaced by better ones until they eventually reach the solution.\nIn both algorithms, the approximate distance to each vertex is always an overestimate of\nthe true distance, and is replaced by the minimum of its old value and the length of a\nnewly found path. However, Dijkstra's algorithm uses a priority queue to greedily select\nthe closest vertex that has not yet been processed, and performs this relaxation process\non all of its outgoing edges; by contrast, the Bellman\u2013Ford algorithm simply relaxes all\nthe edges. In each of these repetitions, the number of vertices with correctly calculated\ndistances grows, from which it follows that eventually all vertices will have their\ncorrect distances. This method allows the Bellman\u2013Ford algorithm to be applied to a wider\nclass of inputs than Dijkstra. [Source: Wikipedia]"}),"\n",(0,l.jsx)(t.p,{children:(0,l.jsx)(t.img,{src:"https://upload.wikimedia.org/wikipedia/commons/2/2e/Shortest_path_Dijkstra_vs_BellmanFord.gif",alt:"Bellman-Ford"})}),"\n",(0,l.jsx)(t.h2,{id:"complexity",children:"Complexity"}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,l.jsx)(t.th,{style:{textAlign:"center"},children:"Worst time"}),(0,l.jsx)(t.th,{style:{textAlign:"center"},children:"Best time"}),(0,l.jsx)(t.th,{style:{textAlign:"left"},children:"Comments"})]})}),(0,l.jsx)(t.tbody,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Bellman ford"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"v * e"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"e"}),(0,l.jsx)(t.td,{style:{textAlign:"left"}})]})})]}),"\n",(0,l.jsx)(t.p,{children:"* Where v = number of vertices; e = number of edges"}),"\n",(0,l.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsx)(t.li,{children:(0,l.jsx)(t.a,{href:"https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/",children:"Geeksforgeeks"})}),"\n",(0,l.jsx)(t.li,{children:(0,l.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm",children:"Wikipedia"})}),"\n",(0,l.jsx)(t.li,{children:(0,l.jsx)(t.a,{href:"https://www.youtube.com/watch?v=FtN3BYH2Zes&ab_channel=AbdulBari",children:"YouTube"})}),"\n",(0,l.jsx)(t.li,{children:(0,l.jsx)(t.a,{href:"https://www.programiz.com/dsa/bellman-ford-algorithm",children:"Programiz"})}),"\n",(0,l.jsx)(t.li,{children:(0,l.jsx)(t.a,{href:"https://cp-algorithms.com/graph/bellman_ford.html",children:"cp-algorithms"})}),"\n",(0,l.jsx)(t.li,{children:(0,l.jsx)(t.a,{href:"https://www.tutorialspoint.com/Bellman-Ford-Algorithm-for-Shortest-Paths",children:"Tutorialspoint"})}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,l.jsx)(t,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}}}]);