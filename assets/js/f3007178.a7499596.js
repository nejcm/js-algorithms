"use strict";(self.webpackChunk_nejcm_js_algorithms=self.webpackChunk_nejcm_js_algorithms||[]).push([[9611],{5068:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Algorithms/Searching/InterpolationSearch","title":"Interpolation Search","description":"Interpolation search is an algorithm for searching for a key in an array that has been","source":"@site/docs/Algorithms/Searching/InterpolationSearch.mdx","sourceDirName":"Algorithms/Searching","slug":"/Algorithms/Searching/InterpolationSearch","permalink":"/js-algorithms/docs/Algorithms/Searching/InterpolationSearch","draft":false,"unlisted":false,"editUrl":"https://github.com/nejcm/js-algorithms/edit/main/docs/Algorithms/Searching/InterpolationSearch.mdx","tags":[],"version":"current","frontMatter":{"name":"Interpolation Search","route":"/algorithms/searching/interpolation-search","menu":"Searching"},"sidebar":"tutorialSidebar","previous":{"title":"Binary search","permalink":"/js-algorithms/docs/Algorithms/Searching/BinarySearch"},"next":{"title":"Jump search","permalink":"/js-algorithms/docs/Algorithms/Searching/JumpSearch"}}');var i=n(4848),s=n(8453);const a={name:"Interpolation Search",route:"/algorithms/searching/interpolation-search",menu:"Searching"},o="Interpolation Search",h={},l=[{value:"Complexity",id:"complexity",level:2},{value:"References",id:"references",level:2}];function c(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"interpolation-search",children:"Interpolation Search"})}),"\n",(0,i.jsx)(t.p,{children:"Interpolation search is an algorithm for searching for a key in an array that has been\nordered by numerical values assigned to the keys (key values). It was first described by\nW. W. Peterson in 1957. Interpolation search resembles the method by which people search a\ntelephone directory for a name (the key value by which the book's entries are ordered): in\neach step the algorithm calculates where in the remaining search space the sought item\nmight be, based on the key values at the bounds of the search space and the value of the\nsought key, usually via a linear interpolation. The key value actually found at this\nestimated position is then compared to the key value being sought. If it is not equal,\nthen depending on the comparison, the remaining search space is reduced to the part before\nor after the estimated position. This method will only work if calculations on the size of\ndifferences between key values are sensible."}),"\n",(0,i.jsx)(t.p,{children:"By comparison, binary search always chooses the middle of the remaining search space,\ndiscarding one half or the other, depending on the comparison between the key found at the\nestimated position and the key sought \u2014 it does not require numerical values for the keys,\njust a total order on them. The remaining search space is reduced to the part before or\nafter the estimated position. The linear search uses equality only as it compares elements\none-by-one from the start, ignoring any sorting. (Source: Wikipedia)"}),"\n",(0,i.jsx)(t.h2,{id:"complexity",children:"Complexity"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Name"}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"Best"}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"Average"}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"Worst"}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"Memory"}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"Stable"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Comments"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Interpolation search"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"1"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"log(log(n))"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"n"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"1"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"Yes"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"For sorted arrays"})]})})]}),"\n",(0,i.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://www.geeksforgeeks.org/interpolation-search/",children:"Geeksforgeeks"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Interpolation_search",children:"Wikipedia"})}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var r=n(6540);const i={},s=r.createContext(i);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);