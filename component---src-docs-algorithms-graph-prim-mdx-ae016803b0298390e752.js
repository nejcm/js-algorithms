(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{Zdoe:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return o})),n.d(t,"default",(function(){return l}));n("5hJT"),n("W1QL"),n("K/PF"),n("t91x"),n("75LO"),n("PJhk"),n("mXGw");var i=n("/FXl"),r=n("TjRS");n("aD51");function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i])}return e}).apply(this,arguments)}var o={};void 0!==o&&o&&o===Object(o)&&Object.isExtensible(o)&&!o.hasOwnProperty("__filemeta")&&Object.defineProperty(o,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/docs/Algorithms/Graph/Prim.mdx"}});var m={_frontmatter:o},s=r.a;function l(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,["components"]);return Object(i.b)(s,a({},m,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h1",{id:"prim"},"Prim"),Object(i.b)("p",null,"Prim's (also known as Jarník's) algorithm is a greedy algorithm that finds a\nminimum spanning tree for a weighted undirected graph. This means it finds a\nsubset of the edges that forms a tree that includes every vertex, where the\ntotal weight of all the edges in the tree is minimized. The algorithm operates\nby building this tree one vertex at a time, from an arbitrary starting vertex,\nat each step adding the cheapest possible connection from the tree to another\nvertex."),Object(i.b)("p",null,"Other well-known algorithms for this problem include Kruskal's algorithm and\nBorůvka's algorithm. These algorithms find the minimum spanning forest in a\npossibly disconnected graph; in contrast, the most basic form of Prim's\nalgorithm only finds minimum spanning trees in connected graphs. However,\nrunning Prim's algorithm separately for each connected component of the graph,\nit can also be used to find the minimum spanning forest. In terms of their\nasymptotic time complexity, these three algorithms are equally fast for sparse\ngraphs, but slower than other more sophisticated algorithms. However, for graphs\nthat are sufficiently dense, Prim's algorithm can be made to run in linear time,\nmeeting or improving the time bounds for other algorithms. ","[Source: Wikipedia]"),Object(i.b)("p",null,Object(i.b)("img",{alt:"Prim's Algorithm",src:"https://upload.wikimedia.org/wikipedia/commons/f/f7/Prim%27s_algorithm.svg"})),Object(i.b)("h2",{id:"minimum-spanning-tree"},"Minimum Spanning Tree"),Object(i.b)("p",null,"A minimum spanning tree (MST) or minimum weight spanning tree is a subset of the\nedges of a connected, edge-weighted undirected graph that connects all the\nvertices together, without any cycles and with the minimum possible total edge\nweight. That is, it is a spanning tree whose sum of edge weights is as small as\npossible. More generally, any edge-weighted undirected graph (not necessarily\nconnected) has a minimum spanning forest, which is a union of the minimum\nspanning trees for its connected components. ","[Source: Wikipedia]"),Object(i.b)("p",null,Object(i.b)("img",{alt:"Minimum Spanning Tree",src:"https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Minimum_spanning_tree.svg/600px-Minimum_spanning_tree.svg.png"})),Object(i.b)("h2",{id:"complexity"},"Complexity"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",a({parentName:"tr"},{align:"left"}),"Name"),Object(i.b)("th",a({parentName:"tr"},{align:"center"}),"Best time"),Object(i.b)("th",a({parentName:"tr"},{align:"left"}),"Comments"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",a({parentName:"tr"},{align:"left"}),"Prim"),Object(i.b)("td",a({parentName:"tr"},{align:"center"}),"v",Object(i.b)("sup",null,"2")),Object(i.b)("td",a({parentName:"tr"},{align:"left"}),"The time complexity can be reduced to log(v) with the help of binary heap.")))),Object(i.b)("p",null,"*"," Where v = number of vertices; e = number of edges"),Object(i.b)("h2",{id:"references"},"References"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",a({parentName:"li"},{href:"https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/"}),"Geeksforgeeks")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",a({parentName:"li"},{href:"https://en.wikipedia.org/wiki/Prim%27s_algorithm"}),"Wikipedia")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",a({parentName:"li"},{href:"https://www.youtube.com/watch?v=4ZlRH0eK-qQ&ab_channel=AbdulBari"}),"YouTube")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",a({parentName:"li"},{href:"https://www.programiz.com/dsa/prim-algorithm"}),"Programiz")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",a({parentName:"li"},{href:"https://cp-algorithms.com/graph/mst_prim.html"}),"cp-algorithms")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",a({parentName:"li"},{href:"https://www.tutorialspoint.com/data_structures_algorithms/prims_spanning_tree_algorithm.htm"}),"Tutorialspoint"))))}void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/docs/Algorithms/Graph/Prim.mdx"}}),l.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-docs-algorithms-graph-prim-mdx-ae016803b0298390e752.js.map