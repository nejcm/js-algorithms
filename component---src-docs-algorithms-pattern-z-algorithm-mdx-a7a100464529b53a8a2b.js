(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{MR3E:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return c})),n.d(t,"default",(function(){return p}));var a=n("Fcif"),i=n("+I+c"),r=(n("mXGw"),n("/FXl")),b=n("TjRS"),c=(n("aD51"),{});void 0!==c&&c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/docs/Algorithms/Pattern/ZAlgorithm.mdx"}});var o={_frontmatter:c},l=b.a;function p(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)(l,Object(a.a)({},o,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"z-algorithm"},"Z algorithm"),Object(r.b)("p",null,'The Z-algorithm finds occurrences of a "word" ',Object(r.b)("inlineCode",{parentName:"p"},"W"),' within a main "text string" ',Object(r.b)("inlineCode",{parentName:"p"},"T")," in\nlinear time ",Object(r.b)("inlineCode",{parentName:"p"},"O(|W| + |T|)"),"."),Object(r.b)("p",null,"Given a string ",Object(r.b)("inlineCode",{parentName:"p"},"S")," of length ",Object(r.b)("inlineCode",{parentName:"p"},"n"),", the algorithm produces an array, ",Object(r.b)("inlineCode",{parentName:"p"},"Z")," where ",Object(r.b)("inlineCode",{parentName:"p"},"Z[i]"),"\nrepresents the longest substring starting from ",Object(r.b)("inlineCode",{parentName:"p"},"S[i]")," which is also a prefix of ",Object(r.b)("inlineCode",{parentName:"p"},"S"),".\nFinding ",Object(r.b)("inlineCode",{parentName:"p"},"Z")," for the string obtained by concatenating the word, ",Object(r.b)("inlineCode",{parentName:"p"},"W")," with a nonce character,\nsay ",Object(r.b)("inlineCode",{parentName:"p"},"$")," followed by the text, ",Object(r.b)("inlineCode",{parentName:"p"},"T"),", helps with pattern matching, for if there is some index\n",Object(r.b)("inlineCode",{parentName:"p"},"i")," such that ",Object(r.b)("inlineCode",{parentName:"p"},"Z[i]")," equals the pattern length, then the pattern must be present at that\npoint."),Object(r.b)("p",null,"While the ",Object(r.b)("inlineCode",{parentName:"p"},"Z")," array can be computed with two nested loops in ",Object(r.b)("inlineCode",{parentName:"p"},"O(|W| * |T|)")," time, the\nfollowing strategy shows how to obtain it in linear time, based on the idea that as we\niterate over the letters in the string (index ",Object(r.b)("inlineCode",{parentName:"p"},"i")," from ",Object(r.b)("inlineCode",{parentName:"p"},"1")," to ",Object(r.b)("inlineCode",{parentName:"p"},"n - 1"),"), we maintain an\ninterval ",Object(r.b)("inlineCode",{parentName:"p"},"[L, R]")," which is the interval with maximum ",Object(r.b)("inlineCode",{parentName:"p"},"R")," such that ",Object(r.b)("inlineCode",{parentName:"p"},"1 ≤ L ≤ i ≤ R")," and\n",Object(r.b)("inlineCode",{parentName:"p"},"S[L...R]")," is a prefix that is also a substring (if no such interval exists, just let\n",Object(r.b)("inlineCode",{parentName:"p"},"L = R = - 1"),"). For ",Object(r.b)("inlineCode",{parentName:"p"},"i = 1"),", we can simply compute ",Object(r.b)("inlineCode",{parentName:"p"},"L")," and ",Object(r.b)("inlineCode",{parentName:"p"},"R")," by comparing ",Object(r.b)("inlineCode",{parentName:"p"},"S[0...]")," to\n",Object(r.b)("inlineCode",{parentName:"p"},"S[1...]"),". (Source: Wikipedia)"),Object(r.b)("h2",{id:"complexity"},"Complexity"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Name"),Object(r.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Preprocessing"),Object(r.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Average"),Object(r.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Worst"),Object(r.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Space"),Object(r.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"Comments"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Z algorithm"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"m"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"n + m"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"n ","*"," m"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"m"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}))))),Object(r.b)("p",null,"*"," Where n = length of the source; m = length of the query pattern; k = size of the\nAlphabet"),Object(r.b)("h2",{id:"references"},"References"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/"}),"Geeksforgeeks")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.hackerearth.com/practice/algorithms/string-algorithm/z-algorithm/tutorial/"}),"Hackerearth")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://ivanyu.me/blog/2013/10/15/z-algorithm/"}),"Z Algorithm by Ivan Yurchenko"))))}void 0!==p&&p&&p===Object(p)&&Object.isExtensible(p)&&!p.hasOwnProperty("__filemeta")&&Object.defineProperty(p,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/docs/Algorithms/Pattern/ZAlgorithm.mdx"}}),p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-docs-algorithms-pattern-z-algorithm-mdx-a7a100464529b53a8a2b.js.map